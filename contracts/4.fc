{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption andecryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encryptein a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters anthe last ASCII
  character shoulgo to the beginning. Return new text encodein cell.
-}

() recv_internal() {
}

tuple generate_tuple(int) asm """
    0 PUSHINT 1 PUSHINT 2 PUSHINT 3 PUSHINT 4 PUSHINT 5 PUSHINT 6 PUSHINT 7 PUSHINT 8 PUSHINT 9 PUSHINT 10 PUSHINT 11 PUSHINT 12 PUSHINT 13 PUSHINT 14 PUSHINT 15 PUSHINT 16 PUSHINT 17 PUSHINT 18 PUSHINT 19 PUSHINT 20 PUSHINT 21 PUSHINT 22 PUSHINT 23 PUSHINT 24 PUSHINT 25 PUSHINT 26 PUSHINT 27 PUSHINT 28 PUSHINT 29 PUSHINT 30 PUSHINT 31 PUSHINT 32 PUSHINT 33 PUSHINT 34 PUSHINT 35 PUSHINT 36 PUSHINT 37 PUSHINT 38 PUSHINT 39 PUSHINT 40 PUSHINT 41 PUSHINT 42 PUSHINT 43 PUSHINT 44 PUSHINT 45 PUSHINT 46 PUSHINT 47 PUSHINT 48 PUSHINT 49 PUSHINT 50 PUSHINT 51 PUSHINT 52 PUSHINT 53 PUSHINT 54 PUSHINT 55 PUSHINT 56 PUSHINT 57 PUSHINT 58 PUSHINT 59 PUSHINT 60 PUSHINT 61 PUSHINT 62 PUSHINT 63 PUSHINT 64 PUSHINT
    65 s() PUSH DUP 0 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 1 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 2 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 3 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 4 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 5 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 6 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 7 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 8 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 9 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 10 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 11 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 12 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 13 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 14 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 15 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 16 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 17 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 18 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 19 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 20 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 21 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 22 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 23 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 24 ADDCONST 26 PUSHINT MOD 65 ADDCONST SWAP DUP 25 ADDCONST 26 PUSHINT MOD 65 ADDCONST NIP
    91 PUSHINT 92 PUSHINT 93 PUSHINT 94 PUSHINT 95 PUSHINT 96 PUSHINT
    97 s() PUSH DUP 0 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 1 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 2 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 3 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 4 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 5 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 6 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 7 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 8 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 9 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 10 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 11 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 12 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 13 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 14 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 15 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 16 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 17 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 18 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 19 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 20 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 21 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 22 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 23 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 24 ADDCONST 26 PUSHINT MOD 97 ADDCONST SWAP DUP 25 ADDCONST 26 PUSHINT MOD 97 ADDCONST NIP
    123 PUSHINT 124 PUSHINT 125 PUSHINT 126 PUSHINT 127 PUSHINT
    128 PUSHINT
    TUPLEVAR
    NIP
""";

builder encrypt(int shift, slice text) {
    tuple res = null();
    builder cur = begin_cell();
    int f? = true;
    tuple t = generate_tuple(shift);
    while (f?) {
        repeat (text.slice_bits() / 8) {
            int c = text~load_uint(8);
            try {
                c = t.at(c);
            } catch (e) { }
            cur~store_uint(c, 8);
        }
        
        if (text.slice_refs_empty?()) {
            f? = false;
        } else {
            text = text~load_ref().begin_parse();
            (res, cur) = (cons(cur, res), begin_cell());
        }
    }

    while (~ res.null?()) {
        cur = (res~list_next()).store_ref(cur.end_cell());
    }

    return cur;
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    builder b = encrypt(shift % 26, text.begin_parse().skip_bits(32));
    return begin_cell().store_uint(0, 32).store_builder(b).end_cell();
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    builder b = encrypt((26 - shift) % 26, text.begin_parse().skip_bits(32));
    return begin_cell().store_uint(0, 32).store_builder(b).end_cell();
}