{-
  TASK 4 - Caesar Cipher
  Implement a Caesar cipher encryption andecryption functions.
  The input is a string (https://docs.ton.org/develop/smart-contracts/guidelines/internal-messages#simple-message-with-comment)
  where the text is encryptein a cell (after 32bit 00000000 prefix flag), the algorithm rotates the characters anthe last ASCII
  character shoulgo to the beginning. Return new text encodein cell.
-}

() recv_internal() {
}

builder encrypt_fast(slice) asm """
    DUP // s s
    SDEPTH // s sd
    REPEAT:<{
        LDREFRTOS // ... s
    }>
    // s0 s1 ... sn

    NEWC // ... b
    SWAP // ... b s
    DUP // ... b s s
    SBITS // ... b s sb
    3 RSHIFT# // ... b s sb/8
    REPEAT:<{
        // ... b s
        8 LDU // ... b x s
        1 GETGLOB // ... b x s t
        ROT // ... b s t x
        INDEXVAR // ... b s x
        ROT // ... s x b
        8 STU // ... s b
        SWAP // ... b s
    }>
    // ... b s
    DROP // ... b
    DEPTH // ... b n+1
    DEC // ... b n
    REPEAT:<{
        // ... b
        ENDC // ... c
        NEWC // ... c b
        STREF // ... b
        SWAP // ... b s
        DUP // ... b s s
        SBITS // ... b s sb
        3 RSHIFT# // ... b s sb/8
        REPEAT:<{
            // ... b s
            8 LDU // ... b x s
            1 GETGLOB // ... b x s t
            ROT // ... b s t x
            INDEXVAR // ... b s x
            ROT // ... s x b
            8 STU // ... s b
            SWAP // ... b s
        }>
        // ... b s
        DROP // ... b
    }>
    // b
""";

builder encrypt_slow(slice) asm """
    DUP // s s
    SDEPTH // s sd
    REPEAT:<{
        LDREFRTOS // ... s
    }>
    // s0 s1 ... sn

    NEWC // ... b
    SWAP // ... b s
    DUP // ... b s s
    SBITS // ... b s sb
    3 RSHIFT# // ... b s sb/8
    REPEAT:<{
        // ... b s
        8 LDU // ... b x s
        OVER // ... b x s x
        122 LEQINT // ... b x s ?
        IF:<{
            1 GETGLOB // ... b x s t
            ROT // ... b s t x
            INDEXVAR // ... b s x
            SWAP // ... b x s
        }>
        s2 XCHG0 // ... s x b
        8 STU // ... s b
        SWAP // ... b s
    }>
    // ... b s
    DROP // ... b
    DEPTH // ... b n+1
    DEC // ... b n
    REPEAT:<{
        // ... b
        ENDC // ... c
        NEWC // ... c b
        STREF // ... b
        SWAP // ... b s
        DUP // ... b s s
        SBITS // ... b s sb
        3 RSHIFT# // ... b s sb/8
        REPEAT:<{
            // ... b s
            8 LDU // ... b x s
            OVER // ... b x s x
            122 LEQINT // ... b x s ?
            IF:<{
                1 GETGLOB // ... b x s t
                ROT // ... b s t x
                INDEXVAR // ... b s x
                SWAP // ... b x s
            }>
            s2 XCHG0 // ... s x b
            8 STU // ... s b
            SWAP // ... b s
        }>
        // ... b s
        DROP // ... b
    }>
    // b
""";

() generate_tuple(int) impure asm """
    dictnew // D
    0 // D 0
    {
        tuck // i D i
        <b 
            // i D i b
            0 // i D i b 0
            {
                tuck // i D i j b j
                8 // i D i j b j 8
                u, // i D i j b
                swap // i D i b j
                1 + // i D i b j+1
            } 65 times // i D i b 65
            {
                tuck // i D i j b j
                65 - // i D i j b j-65
                3 pick // i D i j b j-65 i
                + // i D i j b j-65+i
                26 mod // i D i j b j-65
                65 + // i D i j b j
                8 // i D i j b j 8
                u, // i D i j b
                swap // i D i b j
                1 + // i D i b j+1
            } 26 times // i D i b 91
            {
                tuck // i D i j b j
                8 // i D i j b j 8
                u, // i D i j b
                swap // i D i b j
                1 + // i D i b j+1
            } 6 times // i D i b 97
            {
                tuck // i D i j b j
                97 - // i D i j b j-97
                3 pick // i D i j b j-97 i
                + // i D i j b j-97+i
                26 mod // i D i j b j-97
                97 + // i D i j b j
                8 // i D i j b j 8
                u, // i D i j b
                swap // i D i b j
                1 + // i D i b j+1
            } 26 times // i D i b 123
            drop // i D i b
        b> <s // i D i v
        2 exch // i v i D
        5 // i v i D 5
        udict! // i D ?
        drop // i D
        swap // D i
        1 + // D i+1
    } 26 times // D 26
    drop // D
    PUSHREF // d D
    5 PUSHINT // d D 5
    DICTUGET // s ?
    DROP // s
    8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU 8 LDU
    DROP
    123 PUSHINT
    TUPLEVAR
    1 SETGLOB
""";

builder encrypt(int shift, slice text) {
    generate_tuple(shift);
    try {
        return encrypt_fast(text);
    } catch (e) {
        return encrypt_slow(text);
    }
}

;; testable
(cell) caesar_cipher_encrypt(int shift, cell text) method_id {
    builder b = encrypt(shift % 26, text.begin_parse().skip_bits(32));
    return begin_cell().store_uint(0, 32).store_builder(b).end_cell();
}

;; testable
(cell) caesar_cipher_decrypt(int shift, cell text) method_id {
    builder b = encrypt((26 - shift) % 26, text.begin_parse().skip_bits(32));
    return begin_cell().store_uint(0, 32).store_builder(b).end_cell();
}